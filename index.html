<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绝地对决：士兵突击</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%); /* 更漂亮的天空渐变 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            cursor: crosshair;
            user-select: none;
        }
        #gameCanvas {
            border: 4px solid #2c3e50;
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
            border-radius: 8px;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 1000px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }
        .player-card {
            background: rgba(255,255,255,0.9);
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .player-name { font-weight: 800; font-size: 18px; margin-bottom: 5px; }
        .controls-hint { font-size: 12px; color: #666; }
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 50px 80px;
            border-radius: 20px;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border: 2px solid #fff;
        }
        #game-over h1 { margin: 0 0 20px 0; font-size: 48px; letter-spacing: 2px; }
        #restart-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            transition: transform 0.1s, background-color 0.2s;
            pointer-events: auto;
        }
        #restart-btn:hover { background-color: #c0392b; transform: scale(1.05); }
        #restart-btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="player-card" style="border-left: 5px solid #3498db;">
        <div class="player-name" style="color: #2980b9;">特种兵 (我方)</div>
        <div class="controls-hint">WASD 移动 | 鼠标瞄准点击</div>
    </div>
    <div class="player-card" style="border-right: 5px solid #e74c3c;">
        <div class="player-name" style="color: #c0392b;">雇佣兵 (电脑)</div>
        <div class="controls-hint">自动战斗 AI v2.0</div>
    </div>
</div>

<div id="game-over">
    <h1 id="winner-text">VICTORY!</h1>
    <button id="restart-btn">REPLAY</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- 核心配置 ---
    const CANVAS_WIDTH = 1000;
    const CANVAS_HEIGHT = 600;
    const GROUND_Y = 540;
    const GRAVITY = 0.5;
    const MAX_HEALTH = 3;
    
    // 物理参数
    const PLAYER_SPEED = 4;
    const RELOAD_TIME = 50; // 射击间隔
    const SHOOT_POWER = 22;
    
    // AI 参数
    const AI_MOVE_INTERVAL = 80;
    const AI_SHOOT_CD_MIN = 90;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameOverDiv = document.getElementById('game-over');
    const winnerText = document.getElementById('winner-text');
    const restartBtn = document.getElementById('restart-btn');

    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // 全局状态
    let mouseX = 0, mouseY = 0;
    let keys = { left: false, right: false };
    let isGameOver = false;
    let arrows = [];
    let particles = []; // 用于特效

    // --- 类定义 ---

    class Player {
        constructor(x, color, isAI, teamColor) {
            this.x = x;
            this.y = GROUND_Y - 60; // 稍微高一点，留出腿的空间
            this.width = 40; // 碰撞箱宽度
            this.height = 60; // 碰撞箱高度
            this.color = color;
            this.teamColor = teamColor; // 头盔/衣服的主色调
            this.isAI = isAI;
            
            this.health = MAX_HEALTH;
            this.reloadTimer = 0;
            this.aimAngle = 0;
            this.hitFlashTimer = 0; // 受击闪烁计时器

            // AI 状态
            if (isAI) {
                this.aiMoveTimer = 0;
                this.aiMoveDir = 0;
                this.aiShootTimer = Math.random() * 100;
            }
        }

        takeDamage() {
            this.health--;
            this.hitFlashTimer = 10; // 闪烁10帧
            // 产生受击粒子效果
            createParticles(this.x + this.width/2, this.y + this.height/2, '#FF0000', 10);
            
            if (this.health <= 0) {
                this.health = 0;
                endGame(this.isAI ? "特种兵 (你)" : "雇佣兵 (电脑)");
            }
        }

        update(target) {
            if (isGameOver) return;

            // 0. 受击闪烁计时
            if (this.hitFlashTimer > 0) this.hitFlashTimer--;

            // 1. 移动逻辑
            if (!this.isAI) {
                if (keys.left) this.x -= PLAYER_SPEED;
                if (keys.right) this.x += PLAYER_SPEED;
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH / 2 - 60));
                
                // 玩家瞄准
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 3; // 眼睛位置
                this.aimAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
            } else {
                this.aiBehavior(target);
            }

            // 2. 冷却更新
            if (this.reloadTimer > 0) this.reloadTimer--;
        }

        aiBehavior(target) {
            this.aiMoveTimer--;
            if (this.aiMoveTimer <= 0) {
                this.aiMoveDir = Math.floor(Math.random() * 3) - 1; 
                this.aiMoveTimer = Math.random() * AI_MOVE_INTERVAL + 40;
            }
            this.x += this.aiMoveDir * (PLAYER_SPEED * 0.7);
            this.x = Math.max(CANVAS_WIDTH / 2 + 60, Math.min(this.x, CANVAS_WIDTH - this.width));

            // 瞄准计算 (加入抛物线补偿)
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.abs(dx);
            // AI 精度抖动 (避免百发百中)
            const noise = Math.sin(Date.now() / 500) * 0.1; 
            const gravityComp = dist * 0.65; 
            
            this.aimAngle = Math.atan2(dy - gravityComp, dx) + noise;

            // 射击
            this.aiShootTimer--;
            if (this.aiShootTimer <= 0 && this.reloadTimer === 0) {
                this.shoot();
                this.aiShootTimer = Math.random() * 50 + AI_SHOOT_CD_MIN;
            }
        }

        shoot() {
            if (this.reloadTimer > 0) return;
            
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 3; // 发射点在肩膀位置

            // 枪口修正
            const gunLen = 30;
            const spawnX = centerX + Math.cos(this.aimAngle) * gunLen;
            const spawnY = centerY + Math.sin(this.aimAngle) * gunLen;

            arrows.push(new Arrow(spawnX, spawnY, this.aimAngle, SHOOT_POWER, this.isAI));
            this.reloadTimer = RELOAD_TIME;
            
            // 发射粒子
            createParticles(spawnX, spawnY, '#FFF', 3);
        }

        draw() {
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;

            // 绘制血条 (头顶)
            this.drawHealthBar(cx, this.y - 20);

            ctx.save();
            ctx.translate(cx, cy);

            // 如果受伤，整个身体变红
            if (this.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255,0,0,0.7)';
            }

            // 翻转绘图：如果AI在左边看右边，或者玩家看左边 (为了简化，主要依据aimAngle翻转)
            // 这里我们简化处理：根据 aimAngle 决定是否左右翻转士兵的身体
            const isFacingLeft = Math.abs(this.aimAngle) > Math.PI / 2;
            if (isFacingLeft) {
                ctx.scale(-1, 1); 
            }

            // 1. 绘制身体 (士兵样式)
            this.drawSoldierBody();

            // 2. 绘制手臂和武器 (跟随鼠标旋转)
            this.drawSoldierArm(isFacingLeft ? Math.PI - this.aimAngle : this.aimAngle);

            ctx.restore();
            
            // 绘制装填指示器 (底部)
            if (this.reloadTimer > 0) {
                const pct = (RELOAD_TIME - this.reloadTimer) / RELOAD_TIME;
                ctx.fillStyle = '#555';
                ctx.fillRect(this.x, this.y + this.height + 10, this.width, 4);
                ctx.fillStyle = '#F1C40F';
                ctx.fillRect(this.x, this.y + this.height + 10, this.width * pct, 4);
            }
        }
        
        drawHealthBar(x, y) {
            const heartSize = 12;
            const gap = 5;
            const totalWidth = (MAX_HEALTH * heartSize) + ((MAX_HEALTH - 1) * gap);
            let startX = x - totalWidth / 2;

            for (let i = 0; i < MAX_HEALTH; i++) {
                ctx.beginPath();
                // 简单的矩形代表血格，或者画心
                if (i < this.health) {
                    ctx.fillStyle = '#e74c3c'; // 实心红
                    ctx.strokeStyle = '#c0392b';
                } else {
                    ctx.fillStyle = '#ccc'; // 空血槽
                    ctx.strokeStyle = '#999';
                }
                // 绘制一个小方块代表血量
                ctx.rect(startX + i * (heartSize + gap), y, heartSize, 8);
                ctx.fill();
                ctx.stroke();
            }
        }

        drawSoldierBody() {
            // 腿
            ctx.fillStyle = '#34495e';
            ctx.fillRect(-12, 15, 10, 15); // 左腿
            ctx.fillRect(2, 15, 10, 15);  // 右腿

            // 身体 (制服)
            ctx.fillStyle = this.hitFlashTimer > 0 ? '#FF0000' : this.teamColor;
            ctx.beginPath();
            ctx.roundRect(-15, -10, 30, 28, 4); // 圆角矩形身体
            ctx.fill();

            // 装饰带 (皮带)
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(-15, 10, 30, 4);

            // 头 (皮肤)
            ctx.fillStyle = '#f1c27d'; // 肤色
            ctx.beginPath();
            ctx.arc(0, -18, 12, 0, Math.PI * 2);
            ctx.fill();

            // 头盔
            ctx.fillStyle = '#2c3e50'; // 深色头盔
            ctx.beginPath();
            ctx.arc(0, -20, 13, Math.PI, 0); // 半圆头盔
            ctx.lineTo(13, -20);
            ctx.fill();
            // 护目镜
            ctx.fillStyle = '#3498db';
            ctx.fillRect(-8, -18, 16, 4);
        }

        drawSoldierArm(angle) {
            ctx.save();
            ctx.translate(0, -5); // 肩膀位置
            ctx.rotate(angle);    // 旋转手臂

            // 手臂
            ctx.fillStyle = this.teamColor;
            ctx.beginPath();
            ctx.roundRect(0, -4, 20, 8, 3);
            ctx.fill();

            // 皮肤手
            ctx.fillStyle = '#f1c27d';
            ctx.beginPath();
            ctx.arc(22, 0, 4, 0, Math.PI*2);
            ctx.fill();

            // 武器 (类似火箭筒或弓箭)
            ctx.fillStyle = '#555';
            ctx.fillRect(15, -6, 30, 4); // 枪管
            ctx.fillStyle = '#333';
            ctx.fillRect(15, -2, 10, 6); // 握把

            ctx.restore();
        }
    }

    class Arrow {
        constructor(x, y, angle, speed, isEnemy) {
            this.x = x;
            this.y = y;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.isEnemy = isEnemy;
            this.active = true;
            this.angle = angle;
        }

        update() {
            if (!this.active) return;
            this.vy += GRAVITY;
            this.x += this.vx;
            this.y += this.vy;
            this.angle = Math.atan2(this.vy, this.vx);

            // 击中玩家检测
            const target = this.isEnemy ? player1 : player2;
            if (this.checkCollision(target)) {
                this.active = false;
                target.takeDamage();
                return;
            }

            // 落地或出界
            if (this.y > GROUND_Y || this.x < -100 || this.x > CANVAS_WIDTH + 100) {
                this.active = false;
                // 落地粒子
                if (this.y > GROUND_Y) createParticles(this.x, GROUND_Y, '#8B4513', 5);
            }
        }

        checkCollision(p) {
            // 简单的矩形碰撞
            return (this.x > p.x && this.x < p.x + p.width &&
                    this.y > p.y && this.y < p.y + p.height);
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // 绘制导弹/箭矢样式
            ctx.fillStyle = '#333';
            ctx.fillRect(-10, -2, 20, 4); // 杆
            
            // 弹头颜色区分
            ctx.fillStyle = this.isEnemy ? '#e74c3c' : '#3498db';
            ctx.beginPath();
            ctx.moveTo(10, -4);
            ctx.lineTo(18, 0);
            ctx.lineTo(10, 4);
            ctx.fill();

            // 尾羽
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(-14, -4, 4, 8);

            ctx.restore();
        }
    }

    // 简单的粒子系统
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 3 + 1;
            this.vx = (Math.random() - 0.5) * 5;
            this.vy = (Math.random() - 0.5) * 5;
            this.life = 1.0; // 透明度
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.05;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    // --- 游戏主控 ---
    let player1, player2;

    function init() {
        isGameOver = false;
        arrows = [];
        particles = [];
        gameOverDiv.style.display = 'none';
        
        // 创建玩家 (位置, 颜色, 是否AI, 制服颜色)
        player1 = new Player(100, 'blue', false, '#2980b9'); 
        player2 = new Player(CANVAS_WIDTH - 150, 'red', true, '#c0392b');
    }

    function endGame(winnerName) {
        isGameOver = true;
        winnerText.innerText = winnerName + " 获胜!";
        gameOverDiv.style.display = 'block';
    }

    function drawEnvironment() {
        // 天空已经由CSS背景处理，这里画地面
        ctx.fillStyle = '#795548'; // 土壤
        ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
        
        // 草地装饰
        ctx.fillStyle = '#2ecc71'; // 草地
        ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 15);
        
        // 画一点背景装饰山丘
        ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y);
        ctx.bezierCurveTo(300, 400, 600, 600, 1000, GROUND_Y);
        ctx.fill();
    }

    function loop() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        drawEnvironment();

        player1.update(player2);
        player2.update(player1);

        // 更新并绘制箭
        for (let i = arrows.length - 1; i >= 0; i--) {
            arrows[i].update();
            arrows[i].draw();
            if (!arrows[i].active) arrows.splice(i, 1);
        }

        // 更新并绘制粒子
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        player1.draw();
        player2.draw();

        // 绘制瞄准虚线 (仅玩家)
        if (!isGameOver) drawAimLine(player1);

        requestAnimationFrame(loop);
    }

    function drawAimLine(p) {
        if (p.reloadTimer > 0) return;
        const cx = p.x + p.width/2;
        const cy = p.y + p.height/3;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(p.aimAngle) * 800, cy + Math.sin(p.aimAngle) * 800);
        ctx.stroke();
        ctx.restore();
    }

    // --- 输入监听 ---
    window.addEventListener('keydown', e => {
        if (e.key === 'a' || e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'd' || e.key === 'ArrowRight') keys.right = true;
    });
    window.addEventListener('keyup', e => {
        if (e.key === 'a' || e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'd' || e.key === 'ArrowRight') keys.right = false;
    });
    window.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        mouseX = e.clientX - r.left;
        mouseY = e.clientY - r.top;
    });
    window.addEventListener('mousedown', () => {
        if(!isGameOver) player1.shoot();
    });
    restartBtn.addEventListener('click', init);

    // Start
    init();
    loop();

</script>
</body>
</html>